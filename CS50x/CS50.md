
# Goal

Learn the basics of computer science, and starting to understand how the area of IT work.

Start-Day: 28-05-2020
Finished-Day: 01-07-2020

# Computer Science
CS50

<https://cs50.harvard.edu/college/2020/spring/weeks/0/>



## Week 0

[ScratchEditor](<https://scratch.mit.edu/projects/398747679/editor>)

Binary was 8 light switches

If we want to represet say number 50 we turn the light bulbus
    ?  ?  ?  ?  ?   ?   ?   ?   
    1  2  4  8  16  32  64  128
        |        |    |
        on       on   on

Computer is 0 and 1
0 is 0
01 is 1
11 is two
100 is three
...

Pseudo-code
Problem: Search Mike Smith contact
    Pick up phone book
    Open to middle of phone book
    Look at page
    if Smith is on page
        Call Mike
    Else if Smith is earlier in book
        Open to middle of left half of book
        Go back to line 3
    Else if Smith is later in book
        Open to middle of right half of book
        Go back to line 3
    Else
        Quit

## Week 1

[Sandbox](<https://sandbox.cs50.io/1980a707-94f4-46c3-b86a-6a883220e19a>)


### Compiler

A program that was an input and will transform in to binary language, giving the output


clang - a compiler in C   (where clang stands for “C languages”)
ex: clang hello.c
Exucuting this comand it create a file named a.out
That file is binary code that we can't read
So if we want then to run the program that we write:

    ./a.out
    This means, to the computer run the "a.out" file in the current directory "./"

    // A program that says hello to the world in C

    #include <stdio.h>

        *  main(void)
    {
        printf("hello, world\n");
    }

    >>> Terminal:
    $ clang hello.c
    $ ./a.out
    hello, world

    // if we want that the output file get personal name:
    $ clang -o hello hello.c    -> this will create a output(binary file) named hello

Variables in a string

    #inclue <cs50.h>     -> possible to use string answer in C
    #include <stdio.h>
        *  main(void)
    {
        string answer = get_string("What's your name?\n");
        printf("hello, %s\n", answer);
    }
    // the %s represents the placeholder that the variable answer ill go

    >>> Terminal:
    $ make string
    // with this we can forget the clang ....

### Types, formats, operators

![data-types](./images/data-types-c.png)

* There are other types we can use for our variables
    * bool, a Boolean expression of either true or false
    * char, a single character like a or 2
    * double, a floating-point value with even more digits
    * float, a floating-point value, or real number with a decimal value
    *   * , integers up to a certain size, or number of bits
        * unsigned  *  take away the space of negative number making possible more integer number positive
    * long, integers with more bits, so they can count higher
    * string, a string of characters
* And the **CS50 library** has corresponding functions to get input of various types:
    * get_char
    * get_double
    * get_float
    * get_int
    * get_long
    * get_string
* For printf, too, there are different placeholders for each type:
    * %c for chars
    * %f for floats, doubles
    * %i for ints
    * %li for longs
    * %s for strings
    * %p for adresses (memory)
* And there are some mathematical operators we can use:
    * \+ for addition
    * \- for subtraction
    * \* for multiplication
    * / for division
    * % for remainder

### Float with 2 decimal numbers

    #include <cs50.h>
    #include <stdio.h>

        *  main(void)
    {
        float price = get_float("What's the price?\n$");
        printf("Your total is $%.2f.\n", price * 1.0625);
    }

Our computer has memory, in hardware chips called RAM, random-access memory. Our programs use that RAM to store data as they run, but that memory is finite. So with a finite number of bits, we can’t represent all possible numbers (of which there are an infinite number of). So our computer has a certain number of bits for each float and   * , and has to round to the nearest decimal value at a certain point.

    x: 1
    y: 10
    x / y = 0.10000000149011611938476562500000000000000000000000

It turns out that this is called **floating-point imprecision**, where we don’t have enough bits to store all possible values, so the computer has to store the closest value it can to 1 divided by 10.
Exists to, **integer overflow.**


Syntactic sugar, or shortcuts that have the same effect with fewer characters to type.

# Code Week 1

    #include <stdio.h>
    // to include the get_string function
    #include <cs50.h>
    //indicating that it is a function somewhere in the code so that the main function can be in the top
    void cough( *  number);
    // run while the input is negative
        *  get_positive_int(string prompt);

        *  main(void)
    {
        //asking the name and greetings
        string answer = get_string("what's your name?\n");
        printf("hello, %s\n",answer);

        // getting age in days
            *  age = get_int("what's your age?\n");
            *  days = age*365;
        printf("You age in days is %i\n",days);

        //getting the price with 2 decimal numbers
        float n = get_float("n: ");
        printf("the number with to decimal numbers is %.2f\n",n);

        //cough n times function
            *  number = get_int("How many times you cough?\n");
        cough(number);

        //until number positive
            *  positive = get_positive_int("Please put a positive number:");
        printf("%i\n", positive);
    }

    //function that cough n times 
    void cough( *  number)
    {
        for(    *  i=0; i<number; i++)
        {
            printf("cough\n");
        }
    }
    // run until a positive input
        *  get_positive_int(string prompt)
    {
            *  n;
        do
        {
            n = get_int("%s", prompt);
        }
        while(n < 1);
        return n;
    }

### Conditions

If and else
If, else if,...
And Switch:

    #include <cs50.h>
        *  x = GetInt();
    switch(x)
    {
        case 1:
        printf("one\n");
        break;
        case 2:
        printf("two\n");
        break;
        case 3:
        printf("three\n")
        break;
    }

**break** -> is for the code stop running when the condition is truth. This means that with the it doesnt have break and the conditions was realized at case 2 the output ill be: 

    output:
    two
    three

Another way of if condition:

        *  x = (5<9>) ? printf("truth") : printf("false")

### Loops

**while**
 
* Use when you want a loop to repeat an unknown number of times, and possibly not at all.

**do-while**

* Use when you want a loop to repeat an unknown number of times, but at least once.

**for**

* Use when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled

## CS50 IDE

<https://us-west-2.console.aws.amazon.com/cloud9/ide/?#>

Click inside of that terminal window and then type

    mkdir ~/pset1/

followed by Enter in order to make a directory (i.e., folder) called pset1 in your home directory. Take care not to overlook the space between mkdir and ~/pset1 or any other character for that matter! Keep in mind that ~ denotes your home directory and ~/pset1 denotes a directory called pset1 within ~.

#### Listing Files

Next, in your terminal window, immediately to the right of the prompt (~/pset1/hello/ $), execute

    ls

### Compiling Programs - Options

#### Option with clang

Compiling Programs
Now, before we can execute the hello.c program, recall that we must compile it with a compiler (e.g., clang), translating it from source code into machine code (i.e., zeroes and ones). Execute the command below to do just that:

    clang hello.c

his time, you should see not only hello.c but a.out listed as well? (You can see the same graphically if you click that folder icon again.) That’s because clang has translated the source code in hello.c into machine code in a.out, which happens to stand for “assembler output,” but more on that another time.

Now run the program by executing the below.

    ./a.out

#### Option with clang and file naming

    clang -o hello hello.c

You should now see not only hello.c (and a.out from before) but also hello listed as well? That’s because -o is a command-line argument, sometimes known as a flag or a switch, that tells clang to output (hence the o) a file called hello. Execute the below to try out the newly named program.

    ./hello

#### Option make

Recall that we can automate the process of executing clang, letting make figure out how to do so for us, thereby saving us some keystrokes. Execute the below to compile this program one last time.

    make hello

You should see that make executes clang with even more command-line arguments for you? More on those, too, another time!

### How to Test Your Code

Execute the below to evaluate the correctness of your code using check50. But be sure to compile and test it yourself as well!

    check50 cs50/problems/2020/x/hello

Execute the below to evaluate the style of your code using style50.

    style50 hello.c

### How to Submit

Execute the below, logging in with your GitHub username and password when prompted. For security, you’ll see asterisks (*) instead of the actual characters in your password.

    submit50 cs50/problems/2020/x/hello

### Debugger 

To understand a bug that doesnt compile use **help50** 
If is a bug after compiling, create a stop in left side **debug50 ./bla.c** 

## Week 2

### Explicitly change types of data

    {
        char c1 = 'H';
        char c2 = 'I';
        char c3 = '!';
        printf("%i %i %i\n", (  * ) c1, (    * ) c2, (  * ) c3);
    }

We can take the number of a char (ASCII) and sum or subtract to get another char, like the uppercase for example. 

### Arrays

In C in the arrays dont know their lenght so we need to remember for them so: 
    
        *  scores[3];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;
____________________________________
    #include <cs50.h>
    #include <stdio.h>

    float average(  *  length,   *  array[]);

        *  main(void)
    {
        // Get number of scores
            *  n = get_int("Scores:  ");

        // Get scores
            *  scores[n];
        for (   *  i = 0; i < n; i++)
        {
            scores[i] = get_int("Score %i: ", i + 1);
        }

        // Print average
        printf("Average: %.1f\n", average(n, scores));
    }

    float average(  *  length,   *  array[])
    {
            *  sum = 0;
        for (   *  i = 0; i < length; i++)
        {
            sum += array[i];
        }
        return (float) sum / (float) length;
    }

### String length & eficient loop

When using more than one character in C you have to use "" and with a char ''
strlen() is a function that ill give the size of the string
for this loop the condition could at is below, because all the string in the final they have null '\0'
        
        for (   *  i = 0; s[i] != '\0'; i++)
________
    #include <cs50.h>
    #include <stdio.h>
    #include <string.h>

        *  main(void)
    {
        string s = get_string("Input: ");
        printf("Output: ");
        for (   *  i = 0, n = strlen(s); i < n; i++)
        {
            printf("%c", s[i]);
        }
        printf("\n");
    }

**strlen(s)** ill give us the length of the string, we need to had the library <string.h>

### Functions

![function-anatomy](./images/functios-anatomy.png)


    float multiply_floats(float float1, float float2);

    // a function that multiply two float numbers
    float multiply_floats(float float1, float float2)
    {
    return float1 * float2;
    }

### Arrays

Be caruful in C you can "escape" the bondiries of the array 

    Exemplo:
    //Criation of arrays
    bool truthtable[3] = {false, true, true};
    //or:
    // bool truthtable[3];
    truthtable[0] = false;
    truthtable[1] = true;
    truthtable[2] = true;

![arrays-anatomy](./images/arrays-anatomy.png)

If you already know the number and the what put inside the array you could:
Static initialized array:

        *  number[6] = { 4, 8, 15, 16, 23, 42};

### Command-Line Arguments

Instead of :

        *  main(void){

    }

We know ill use the :

        *  main(   *  argc, string argv[]){

    }

The reason is that instead of use get_int, etc with this two special arguments enable you to know what data the user provided at the command line and how much data they provided.

**argc**  -> intiger, ill give the number of command-lines the user typed when the program was executed ( it counts the start of the program)

![argc](./images/main-function-argc.png)

**argv** -> array (called vector two), that ill store in which element the actual text the user typed at the command-line when the program was executed.

* The first element of argv is always found at argv[0]. The last element of argv is always found at argv[argc-1].

### Variables and Scope

If a variable is declared outside of all functions, any function may refer to it.

We can use the **const** keyword to tell the compiler that the **value of N should never be changed by our program.** And by convention, we’ll place our **declaration of the variable outside of the main function** and capitalize its name, which isn’t necessary for the compiler but shows other humans that this variable is a constant and makes it easy to see from the start.

### Compiling

* We compiled it with **clang hello.c** to be able to run ./a.out (the default name), and then **clang -o hello hello.c** (passing in a command-line argument for the output’s name) to be able to run ./hello.
* We wanted to use CS50’s library, via #include <cs50.h>, for strings and the get_string function, we also have to add a flag: **clang -o hello hello.c -lcs50.** The -l flag links the cs50 file.

“Compiling” source code into machine code is actually made up of smaller steps:
* preprocessing
* compiling
* assembling
* linking

**Preprocessing** involves looking at lines that start with a #, like #include, before everything else. For example, #include <cs50.h> will tell clang to look for that header file first, since it contains content that we want to include in our program. Then, clang will essentially replace the contents of those header files into our program.

**Compiling** takes our source code, in C, and converts it to assembly code.

The next step is to take the **assembly** code and translate it to instructions in binary by assembling it. The instructions in binary are called machine code, which a computer’s CPU can run directly.

The last step is **linking,** where the contents of previously compiled libraries that we want to link, like cs50.c, are actually combined with the binary of our program. So we end up with one binary file, a.out or hello, that is the compiled version of hello.c, cs50.c, and printf.c.

### Debugging & Style

Run **debug50 ./buggy2,** we’ll see the debugger panel open on the right.

**style50** is another program that will check our code for aesthetic issues, such as whitespace, such that our code is more readable and maintainable. 

[Style Sheet in C](<https://cs50.readthedocs.io/style/c/>)

# Code week 3

## Custom types

    typedef struct
    {
        string names;
        string numbers;
    }
    person;

This means that now is a "person" type (outside main)

        *  main(void)
    {
        person people[4];
        people[0].name = "EMMA";
        people[0].number = "617-555-0100";

        people[1].name = "RODRIGO";
        people[0].number = "617-555-0101";
        .
        .
        .
    }

## Algotithms

### Recursion

Recursion is a function that call it self
    
    void draw(  *  h)
    {
        if (h == 0)
        {
            return;
        }

        draw(h-1);

        for (   *  i = 0; i < h; i++)
        {
            printf("#");
        }
        printf("\n");
    }
___________________________
    #include <cs50.h>
    #include <stdio.h>

        *  collatz(    *  n);

        *  main (void)
    {
            *  colat = collatz(3);
        printf("collatz: %i\n", colat);
    }

        *  collatz(    *  n)
    {
        if (n == 1)
        {
            return 0;
        }
        else if(n % 2 == 0)
        {
            return 1 + collatz (n / 2);
        }
        else
        {
            return 1 + collatz (3 * n + 1);
        }
    }

### Call Stack
![call-stack](./images\call-stack.png)

To understand recursion you need to understand the call stack, in the example above, all functions are called until the last one (the top) returns, then the other that here waiting ill be called one at a time from top to bottom.

[call-stack video](https://www.youtube.com/watch?v=aCPkszeKRa4)

### Efeciency
*O* -> in order of... worst cases.

Computer scientists might also use big Ω, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) 

This is said to understand the speed of the algorithms, like in order of O(n) , O(n/2), O(log n)

*Omega* -> oposite of *o*, (*o* is worst cases), omega is **best cases**.

Omega (1) -> represent the best chance to find, the best case.

*O*(n) -> is the worst case, we have to see truth every single element and dont find what we are looking for

* Linear Search : *O*(n) / omega(1)
    - Pass truth the data (1 by 1) until finds what we are looking for

* Binary search: *O*(log n)/ Omega(1)
    - The data was to be sorted
    - Log n means that is dividing and dividing but dont found *O*(log n)

* Buble sort  (search) : *O*(n2) / omega(n) -> the most inneficience
    - Swap adjacent pair if the left is bigger swap them making the smallest in the right
    - In the worst case you have to sort the bigger number to the right and sort the smalest number to the left, making **n2** 
    - But if in the best case scenario is already sorted so omega n, to pass only once in to the n data.

* Selection Sort : *O*(n2) / omega(n2)
    - find the smallest element in the array
    - swap smallest element with the "first number ([n+count])"
    - n2 means that it was to pass n times truth n times to sort

*Omega* -> oposite of *o*, (*o* is worst cases), omega is best cases

Omega (1) -> represent the best chance to find, the best case.

![Order](./images\order-of-algorithms.png)
![Omega](./images\omega-of-algorithms.png)

#### Sorting - merge sort
Better eficience:
*O* and omega (n log n); 
Log n means that is dividing and dividing 
In the image below in (8 log 8)

![sorting-merge](images\sorting-merge.png)

* In merge sort, the idea of the algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order.
* Moresort leverage something called recursion

In pseudocode:
* Sort the left half of the array (assuming n> 1)
* Sort the right half of the array (assuming n> 1)
* Merge the two halves together

[Merge-Sort video](<https://www.youtube.com/watch?v=Ns7tGNbtvV4>)

## Week 4

### Memory

* It turns out that, by convention, the addresses for memory use the counting system hexadecimal, where there are 16 digits, 0-9 and A-F.

* Recall that, in binary, each digit stood for a power of 2:
    
    128 64 32 16  8  4  2  1
      1  1  1  1  1  1  1  1

With 8 bits, we can count up to 255.

* It turns out that, in hexadecimal, we can perfectly count up to 8 binary bits with just 2 digits:

    16^1 16^0
       F    F

Here, the F is a value of 15 in decimal, and each place is a power of 16, so the first F is 16^1 * 15 = 240, plus the second F with the value of 16^0 * 15 = 15, for a total of 255.


#### Pointers

* In our computer’s memory, there are now 4 bytes somewhere that have the binary value of 50, labeled n
* It turns out that, with the billions of bytes in memory, those bytes for the variable n starts at some unique address that might look like 0x12345678 (arbitrary number).
* In C, we can actually see the address with the **& operator,** which means “get the address of this variable”:
   
        #include <stdio.h>

            *  main(void)
        {
                *  n = 50;
            printf("%p\n", &n);
        }

* The address of a variable is called a pointer, which we can think of as a value that “points” to a location in memory. The **\* operator** lets us “go to” the location that a pointer is pointing to.
* For example, we can print *&n, where we “go to” the address of n, and that will print out the value of n, 50, since that’s the value at the address of n
* We also have to use the * operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer:

        #include <stdio.h>

            *  main(void)
        {
            *  n = 50;
            *  *p = &n;
        printf("%p\n", p);
        }

*   * * p; -> declaring a pointer
*   * * p = &n; -> giving p the adress 0x123456 (p = 0x123456)
*   *  *p = &n; -> gives the value that is in the adress 0x123456 (p = 50)

#### String

* We might have a variable string s for a name like EMMA, and be able to access each character with s[0] and so on.
* But it turns out that each character is in stored in memory at a byte with some address, and s is actually just a pointer with the address of the first character
* And since s is just a pointer to the beginning, only the \0 indicates the end of the string.
* This is familiar, but we can just say (string == char* , that string is given by the Library CS50)

        #include <stdio.h>

            *  main(void)
        {
            char *s = "EMMA";
            printf("%s\n", s);
        }
        //output : 0x132456
____
        #include <stdio.h>

            *  main(void)
        {
            char *s = "EMMA";
            printf("%c\n", *s);
            printf("%c\n", *(s+1));
        }
        //output : 
            E
            M
* \* -> This means go to
* \& -> This means the adress
* printf -> have the config to print the beginning the adress until \0 (null)

To copy a string :

        string s = "EMMA";
        string t = s;
        // e se depois quisermos alterar algo na variavel t
        t[0] = toupper(t[0]);
        // isto vai alterar a variavel s tambem, pois t esta a apontar para a "adress" de s.
______________

* To actually make a copy of a string, we have to do a little more work:

        #include <cs50.h>
        #include <ctype.h>
        #include <stdio.h>
        #include <string.h>

            *  main(void)
        {
            char *s = get_string("s: ");

            char *t = malloc(strlen(s) + 1);

            for (   *  i = 0, n = strlen(s); i < n + 1; i++)
            {
                t[i] = s[i];
            }

            t[0] = toupper(t[0]);

            printf("s: %s\n", s);
            printf("t: %s\n", t);

            free(t);
        }

* With **malloc,** we can allocate some number of bytes in memory (that aren’t already used to store other values), and we pass in the number of bytes we’d like. We already know the length of s, so we add 1 to that for the terminating null character(\0). So, our final line of code is char *t = malloc(strlen(s) + 1);.
* **Malloc** ill for ever allocate the adress unless we use **free()**
    - **free(t)** ill free the memory, use it when you dont need anymore t
* We can actually also use the strcpy library function with strcpy(t, s) instead of our loop, to copy the string s into t.
* what if malloc() can't give you memory? it'll hand you back null so is better to always condition the variable right after malloc to see if == NULL
*   *  *px = malloc(sizeof(  * )); -> ill find 4 bytes in heat
* float* heap_array = malloc(x * sizeof(float)); -> this ill give a space in memory x times a size of a float

Rules: 
* Every you malloc you should right after you dont need it
* Do not free() a block of memory more than once
* Only memory that you malloc() should be free().

![visual-example](./images\visual-example.png)

#### valgrind

* It turns out that, after we’re done with memory that we’ve allocated with malloc, we should call free (as in free(t)), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again.
* If we kept running our program and allocating memory with malloc, but never freed the memory after we were done using it, we would have a memory leak, which will slow down our computer and use up more and more memory until our computer runs out.
* valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with help50 valgrind ./copy and see, from the error message, that line 10, we allocated memory that we never freed (or “lost”).

        valgrind ./copy

### Swap

* Now, let’s say we wanted to swap the values of two integers.

        #include <stdio.h>

        void swap(  *  a,    *  b);

            *  main(void)
        {
                *  x = 1;
                *  y = 2;

            printf("x is %i, y is %i\n", x, y);
            swap(x, y);
            printf("x is %i, y is %i\n", x, y);
        }

        void swap(  *  a,    *  b)
        {
                *  tmp = a;
            a = b;
            b = tmp;
        }

 But, if we tried to use that function in a program, we don’t see any changes
 
 By passing in the address of x and y, our swap function can actually work:

        #include <stdio.h>

        void swap(  *  *a,   *  *b);

            *  main(void)
        {
                *  x = 1;
                *  y = 2;

            printf("x is %i, y is %i\n", x, y);
            swap(&x, &y);
            printf("x is %i, y is %i\n", x, y);
        }

        void swap(  *  *a,   *  *b)
        {
                *  tmp = *a;
            *a = *b;
            *b = tmp;
        }

### Memory layout

* The machine code section is our compiled program’s binary code. When we run our program, that code is loaded into the “top” of memory.
* Globals are global variables we declare in our program or other shared variables that our entire program can access.
* The heap section is an empty area where malloc can get free memory from, for our program to use.
* The stack section is used by functions in our program as they are called. For example, our main function is at the very bottom of the stack, and has the local variables x and y. The swap function, when it’s called, has its own frame, or slice, of memory that’s on top of main’s, with the local variables a, b, and tmp

![memory-layout](./images\memory-layout.png)

### get_int / get_string

* We can implement get_int ourselves with a C library function, scanf:
      
        #include <stdio.h>

            *  main(void)
        {
                *  x;
            printf("x: ");
            scanf("%i", &x);
            printf("x: %i\n", x);
        }

* scanf takes a format, %i, so the input is “scanned” for that format, and the address in memory where we want that input to go. But scanf doesn’t have much error checking, so we might not get an integer.

We can try to get a string the same way:

        #include <stdio.h>

            *  main(void)
        {
            char *s = NULL;
            printf("s: ");
            scanf("%s", s);
            printf("s: %s\n", s);
        }

* But we haven’t actually allocated any memory for s (s is NULL, or not pointing to anything), so we might want to call char s[5] to allocate an array of 5 characters for our string. Then, s will be treated as a pointer in scanf and printf.

Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash.

### Files

* With the ability to use pointers, we can also open files:

        #include <cs50.h>
        #include <stdio.h>
        #include <string.h>

            *  main(void)
        {
            // Open file
            FILE *file = fopen("phonebook.csv", "a");

            // Get strings from user
            char *name = get_string("Name: ");
            char *number = get_string("Number: ");

            // Print (write) strings to file
            fprintf(file, "%s,%s\n", name, number);

            // Close file
            fclose(file);
        }

* fopen is a new function we can use to open a file. **It will return a pointer to a new type, FILE,** that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in **(r for read, w for write, and a for append, or adding to)**.
* After we get some strings, we can use fprintf to print to a file.
* Finally, we close the file with fclose.
* Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically.

#### File Pointers

* fopen()
    - Opens a file and returns a file pointer to it
    - Always check the return value to mkae sure you dont get back NULL.

             FILE* ptr = fopen(<filename>, <operation>);

    - \<operation>:
        * r - for read
        * w - for write (ill overwrite if the file has already written)
        * a - for append or add (the difference of write is that ill add in the end of the file)
    * Important to understand that the operation is how we ill work in that file and imagine that we want to write and read, you ill have to do 2 opens one with operator "w" and other with "r"
* fclose()
    - Closes the file pointed to by the given file pointer

            fclose(<file pointer>);
* fgetc()
    - need the file to be open was "r" reading
    - it ill give you the next chararacter of the file

            char ch = fgetc(<file pointer>);

        * Example of use (priting all the text of a file in the terminal):

                char ch;
                while((ch = fgetc(ptr)) != EOF)
                    printf("%c", ch);
                
            - EOF - means end of the file

* fputc()
    - Writes or appends the specified character to the pointed-to file.
    - The operation in the file pointer must be "w" or "a"

            fputc(<character>, <file pointer>);

* fread()
    - Is like fgetc() but is not limited to one char at a time
    - Reads \<qty> units of size \<size> from the file pointed to and stores them in memory in a buffer (usually an array) pointed to by \<buffer>.

            fread(<buffer>, <size>, <qty>, <file pointer>);

        - Example :

                    *  arr[10];
                fread(arr, sizeof(  * ), 10, ptr);

                char c;
                fread( &c, sizeof(char), 1, ptr);

            - &c because the buffer is a pointer so we need to give the adress

* fwrite()
    * Simialiar with fread() but writes instead of read

            fwrite(<buffer>, <size>, <qty>, <file pointer>);

* More file pointers:

![file-pointers](./images\file-pointers.png)

### Comparing files

* We can also write a program that opens a file and tells us if it’s a JPEG (image) file:

        #include <stdio.h>

            *  main(   *  argc, char *argv[])
        {
            // Check usage
            if (argc != 2)
            {
                return 1;
            }

            // Open file
            FILE *file = fopen(argv[1], "r");
            if (!file)
            {
                return 1;
            }

            // Read first three bytes
            unsigned char bytes[3];
            fread(bytes, 3, 1, file);

            // Check first three bytes
            if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
            {
                printf("Maybe\n");
            }
            else
            {
                printf("No\n");
            }

            // Close file
            fclose(file);
        }

* Now, if we run this program with ./jpeg brian.jpg, our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread.
* We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they’re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they’re not the same, we know it’s definitely not a JPEG file.

## Week 5 Data Structure

* realloc()
  - realocate new memory, in the example below you realocate a memory of 3 ints to 4 ints and now you can pass new data to the structure
    
                *  main(void)
        {
            // List of size 3
                *  *list = malloc(3 * sizeof(  * ));
            if (list == NULL)
            {
                return 1;
            }

            // Initialize list of size 3 with numbers
            list[0] = 1;
            list[1] = 2;
            list[2] = 3;

            // Resize list to be of size 4
                *  *tmp = realloc(list, 4 * sizeof(    * ));
            if (tmp == NULL)
            {
                return 1;
            }
            list = tmp;

            // Add number to list
            list[3] = 4;

            // Print list
            for (   *  i = 0; i < 4; i++)
            {
                printf("%i\n", list[i]);
            }

            // Free list
            free(list);
        }

#### Data Structure

* struct
* . -> to get acess to the property of the data structure
* \* -> go to a chucnk of memory

#### Link List

Node represent a chunk of memory 
In computer memory not always you have space right beside that adress, if we want to amplifie our array we need to get the adress that ill give us the adress of the other value.

two filds in data structure, the value and the adress to the next number that we want to follow.

![linked-list](./images\linked-list.png)

        typedef struct node
        {
                *  number;
            struct node *next;
        }
        node;


Creating a link list:

![likind-List-1º](./images\linked-list-foramttion.png)

To go to 2:

        node *n = malloc(sizeof(node));
        if (n != NULL)
        {
            n->number = 2;
            n->next = NULL;
        }

* n->number is saying go to the adress *n the part that has number  and equal 2
* n->next is null for now because you dont have any adress next that you want
    - To see if a linked list continuous:

            node *temp = list;
            while (tmp ->next != null)
            {
                tmp = tmp->next;
            }

    This means that if list is not pointing to anything (NULL) tha stop, you reached the end of the list, if you got an adress continuo until you arrived to the final element of the linked list

#### In code example

        // Implements a list of numbers with linked list

    #include <stdio.h>
    #include <stdlib.h>

    // Represents a node
    typedef struct node
    {
            *  number;
        struct node *next;
    }
    node;

        *  main(void)
    {
        // List of size 0
        node *list = NULL;

        // Add number to list
        node *n = malloc(sizeof(node));
        if (n == NULL)
        {
            return 1;
        }
        n->number = 1;
        n->next = NULL;
        list = n;

        // Add number to list
        n = malloc(sizeof(node));
        if (n == NULL)
        {
            return 1;
        }
        n->number = 2;
        n->next = NULL;
        list->next = n;

        // Add number to list
        n = malloc(sizeof(node));
        if (n == NULL)
        {
            return 1;
        }
        n->number = 3;
        n->next = NULL;
        list->next->next = n;

        // Print list
        for (node *tmp = list; tmp != NULL; tmp = tmp->next)
        {
            printf("%i\n", tmp->number);
        }

        // Free list
        while (list != NULL)
        {
            node *tmp = list->next;
            free(list);
            list = tmp;
        }
    }

## Types of Data structure

#### Arrays

* Insertion is bad - lots of shifting to fit an element in the middle
* Deletion is bad - lots of shifting after removing an element
* Lookup is great - random access, constant time
* Relatively easy to sort
* Relatively small size-wise
* Stuck with a fixed size, no flexibility

#### Linked Lists & Double Linked Lists

* Avaliation:
    * Insertion is easy - just tack onto the front
    * Deletion is easy - once you find the element
    * Lookup is bad - have to rely on linear search
    * Relatively difficult to sort - unless you're willing to compromise on super-fast insertion and instead sort as you construct
    * Relatively small size-wise (not as small as arrays)

* A linked list node is a special kind of struct with two members:
    * Data of some data type (  * ,char,float,...)
    * A pointer to another node of the same type

            // Represents a node
                typedef struct node
                {
                        *  number;
                    struct node *next;
                }
                node;

##### Operations with linked lists

* Create a linked list when it doesn't already exist:
    
            sllnode* create(VALUE val);
            sllnode* new = create(6);

    * Steps Involved:
        - Dynamically allocate space for a new sllnode (malloc())
        - Check to make sure we didnt run out of memory (sllnode == NULL)
        - Initialize the node's val field (6)
        - Return a pointer to the newly created sllnode
         
* Search through a linked list to find an element:
    - Best practive colocate in a global variable the first pointer of the list

            bool find(sllnode* head, VALUE val);
            bool exists = find(list, 6);

    * Steps Involved:
        - Create a traversal pointer pointing to the list's head
        - If the current node's val field is what we're looking for, report sucess
        - If not, set the traversal pointer to the next pointer in the list and go back to step b
        - If you've reached the end of the list, report failure

* Insert a new node into the linked list:
    
        sllnode* insert(sllnode* head, VALUE val);
    
    * Steps Involved:
        - Dynamically allocate space for a new sllnode
        - Check to make sure we didn't run out of memory
        - Populate and insert the node **at the beginning of the linked list**
        - Return a pointer to the new head of the linked list

* Delete a single element from a linked list (double linked lists)
* Delete an entire linked list:

![linked-list](./images\destroy-linked-list.png)
    
            void destroy(sllnode* head);
            destroy(list);

            // Free list
            while (list != NULL)
            {
                node *tmp = list->next;
                free(list);
                list = tmp;
            }
    
    * Steps Involved:
        - If you've reached a null pointer, stop
        - Delete **the rest of the list** (recursion)
        - Free the current node

##### Operations with Double linked lists

        typedef struct dllist
        {
            VALUE val;
            struct dllist* prev;
            struct dllist* next;
        }
        dllnode;

* Insert a new node into the linked list:

        dllnode* insert(dllnode* head, VALUE val);
        list = insert(list,12);

    * Steps Involved:
        - Dynamically allocate space for a new sllnode
        - Check to make sure we didn't run out of memory
        - Populate and insert the node at the beginning of the linked list
        - **Fix the prev pointer of the old head of the linked list**
        - Return a pointer to the new head of the linked list

* Delete a single element from a linked list:
    
            void delete(dllnode* target);
            delete(x);

    * Steps Involved:
        - Fix the pointers of the surrounding nodes to "skip over" target
        - Free target

#### Hash tables

* A good hash function should:
        - Use only the data being hashed
        - Use all of the data being hashed
        - Be deterministic (if we pass the same data hundred times the result is the same)
        - Uniformly distribute data
        - Generate very different hash codes for every similar data

* It's better to find a good hash table in the internet, because its more a art than a science
* Resolving collisions (occurs when two pieces of data, when run through the hash function, yield the same hash code):
    - Linear Probing:
        - In this method, if we have a collision, we try to place the data in the next consecutive element in the array (wrapping around to the beginning if necessary) until we find a vacancy. (hashCode + 1)
    - Chaining:
        - If each element of the array is a pointer to the head of a linked list, then multiple pieces of data can yield tha same hash code and we'll be able to store it all!

* Insertion is a two-step process - hash, then add
* Deletion is easy - once you find the element
* Lookup is on average than with linked lists because you have the benefit of a real-world constant factor
* Not an ideal data structure if sorting is the goal - just use an array
* Can run the gamut of size

#### Tries

* Combine structures and pointers together to store data in an interesting way
* The data to be searched for in the trie is now a roadmap
    * If you can follow the map from beginning to end, the data exists in the trie
    * If you can't, it doesn't
* Unlike with a hash table, there are no collisions, and no two pieces of data(unless they are identical) have the same path

* Avaliation:
    * Insertion is complex - a lot of dynamic memory allocation, but gets easier as you go
        * To insert an element into the trie, simply build the correct path from the root to the leaf.

                typedef struct _trie
                {
                    char university[20];
                    // represent every node ill have 9 path to follow
                    struct _trie* paths[10]; 
                }
                trie
![tries-inser](./images\tries-insert.png)

    * Deletion is easy - just free a node
    * Lookup is fast - not quite as fast as an array, but almost
    * Already sorted - sorts as you build in almost all situations
    * Rapidly becomes huge, even with very little data present, not great if space is at a premium

#### Stacks

* Array-based implementation

        typedef struct _stack
        {
            VALUE array[CAPACITY];
                *  top;
        }
        stack
* Push:
    * Add a new element to the top of the stack

            void push(stack* s, VALUE data);

            stack s;
            s.top = 0;
            push(&s, 28); // now the top of the stack ill have the value 28
            // now we have to update the top of the stack
            s.top++;

        * In general need:
         - Accept a **pointer to the stack**
         - Accept a data of type VALUE to be added to the stack
         - Add that data to the stack at the top of the stack
         - Change the location of the top of the stack

* Pop:
    * Remove the most recent element from the top of the stack
        
            VALUE pop(stack* s);
                *  x = pop(&s);
            s.top--;
        
        * In general need:
            - Accept a pointer to the stack
            - Change the location of the top of the stack
            - Return the value that was removed from the stack


#### Queues

* Enqueue: add a new element to the end of the queue
* Dequeue: Remove the oldest element from the front of the queue

            typedef struct _queue
            {
                VALUE array[CAPACITY];
                    *  front;   // to know the element in the queue
                    *  size;   // how many elements exists in the queue right now
            }
            queue;

* In general in enqueue() need:
    - Accept a pointer to the queue
    - Accept data of type VALUE to be added to the queue
    - Add that data to the queue at the end of the queue
    - Change the size of the queue


            void enqueue(queue* q, VALUE data);
            queue q;
            enqueue(&q, 28);
            queue.size++;
            //now lets add another
            enqueue(&q, 33);
            queue.size++;

            // in queue we know here to put the value in the array by array[queue.size + queue.front]

* In general in dequeue() need:
    - Accept a pointer to the queue
    - Change the location of the front of the queue
    - Decrease the size of the queue
    - Return the value that was removed from the queue

                *  x = dequeue(&q);
            queue.front++; // because now this it the new element in front of the queue
            // removed the last element in the queue (28)
            queue.size--;

#### Queue with double linked list

* To enqueue:
    * Dynamically allocate a new node;
    * Set its next pointer to NULL, set its prev pointer to the tail
    * Set the tail's next pointer to the new node
    * Move the tail pointer to the newly-created node

* To dequeue():
    - Traverse the linked list to its second element (if it exists)
    - Free the head of the list
    - Move the head pointer to the (former) second element
    - Make that node's prev pointer point to NULL


# Functions

<https://man.cs50.io/>

### #include <stdio.h>

### #include <cs50.h>

### #include <math.h>

* round(x)
    - These functions round x to the nearest integer, but round halfway cases away from zero

### #include <string.h>

* strcpy(t, s)
    - Copy the string in variable s to the variable t
* strlen()
    - calculates the length of the string pointed to by s, excluding the terminating null byte ('\0')
* if (strcmp(("EMMA", "EMMA") == 0)
    - Compare to strings and return 0 when match


## week 6 - Python

<https://www.youtube.com/watch?v=mgBpcQRDtl0>

##### Printing

    print("hello world")

    answer = get_string("what's your name?")
    print("hello, " + answer)
    print("hello,",answer)
    print(f"hello, {answer}")
    print("?", end="")
    print("cough" * 4)


##### Increment a variable

    counter = 0
    counter = counter + 1
    counter += 1
    XX counter++ XX  -> wrong in python

##### Running Python programs

* Python is an interpreted language, which means that we actually run another program (an interpreter) that reads our source code and runs it top to bottom. For example, we can save the above as hello.py, and run the command python hello.py to run our code, without having to compile it.

##### Conditions:

    if x < y:
        print("x is less than y")
    elif x > y:
        print("x is greater than y")
    else:
        print("x is equal to y")
_________
    from cs50 import get_string

    s = get_string("Do you agree?\n")

    if s == "Y" or s == "y":
        print("Agreed.")
    elif s == "N" or s == "n":
        print("Not agreed.")

* || = or 
* && = and
* != = not


##### Boolean Expressions

    while True:
    print("hello, world")

##### Loops

* It only exists two types of loops, for loops and while loops

        for i in [0, 1, 2]:
            print("cough")
        # or:
        for i in range(3)
            print("cough")

* We can define a function to get a positive integer:

        from cs50 import get_int

        def main():
            i = get_positive_int()
            print(i)

        def get_positive_int():
            while True:
                n = get_int("Positive Integer: ")
                if n > 0:
                    break
            return n

        main()

* Since there is no do-while loop in Python as there is in C, we have a while loop that will go on infinitely, but we use break to end the loop as soon as n > 0. Then, our function will just return n.

        for x in range(0, 100 , 2):
            print(x)

* this ill count until 100, not inclusive, and skip two by two, 0..2..4..98

##### Lists (arrays)

* Lists in Python are like arrays in C, but they can grow and shrink easily with the interpreter managing the implementation and memory for us.

        scores = []
        scores.append(72)
        scores.append(73)
        scores.append(33)

        print(f"Average: {sum(scores) / len(scores)}")
_____
        nums = [x for x in range(500)]
        nums = [1, 2, 3, 4]
        nums.inser(4, 5) # it ill append in 4 index 5
        nums[len(nums):] = [5] ## it ill append in : the 5

* We can also declare a list with some values like scores = [72, 73, 33].

##### Data Types

* In Python, there are many data types:
    * bool, True or False
    * float, real numbers
    * int, integers
    * str, strings
    * range, sequence of numbers
    * list, sequence of mutable values, that we can change or add or remove
    * tuple, sequence of immutable values, that we can’t change
    * dict, collection of key/value pairs, like a hash table
    * set, collection of unique values

###### Tupples

        presidents = [
            ("George Washington", 1789),
            ("John Adams", 1797),
            ("Thomas Jefferson", 1801),
            ("James Madison", 1809)
        ]

        for prez, year in presidents:
            print("In {1}, {0} took office".format(year, prez))

###### Dictionaries (hash tables)

        pizzas = {
            "cheese": 9,
            "pepperoni": 10,
            "vegetable": 11,
            "buffalo chicken": 12
        }

        if pizza["vegetables"] < 12:
            # do something
        
        pizzas["bacon"] = 14 #add key value pair
        for pie in pizzas:
            # use pie in here as a stand in for "i"
        
        for pie, price in pizzas.items():
            print("A whole {} pizza costs ${}".format(pie, price))

##### Functions

    def main():
        for i in range(3):
            cough()

    def cough():
        print("cough")

    main()

* Now, by the time we actually call our main function, the cough function will have been read by our interpreter.

* Our functions can take inputs, too:

        def main():
        cough(3)

        def cough(n):
            for i in range(n):
                print("cough")

        main()

* to do square 3**2 = 9

##### Objects

        class student():

            def __init__(self, name, id):
                self.name = name
                self.id = id

            def changeID(self, id):
                self.id = id
            
            jane = Student("Jane", 10)
            jane.print()
            jane.changeID(11)
            jane.print()

##### Command Lines Arguments

        from sys import argv

        for i in range(len(argv)):
            print(argv[i])

* Since argv is a list of strings, we can use len() to get its length, and range() for a range of values that we can use as an index for each element in the list.

* to run python program
    
        phyton \<file>

##### Exit (return)

* We can return exit codes when our program exits, too:

        from sys import argv, exit

        if len(argv) != 2:
            print("missing command-line argument")
            exit(1)
        print(f"hello, {argv[1]}")
        exit(0)

##### Data Structures , ALgorithms Sorting

* We can implement linear search by just checking each element in a list:

        import sys

        names = ["EMMA", "RODRIGO", "BRIAN", "DAVID"]

        if "EMMA" in names:
            print("Found")
            sys.exit(0)
        print("Not found")
        sys.exit(1)

* If we have a dictionary, a set of key:value pairs, we can also check each key:

        import sys

        people = {
            "EMMA": "617-555-0100",
            "RODRIGO": "617-555-0101",
            "BRIAN": "617-555-0102",
            "DAVID": "617-555-0103"
        }

        if "EMMA" in people:
            print(f"Found {people['EMMA']}")
            sys.exit(0)
        print("Not found")
        sys.exit(1)

##### Examples of exercices

We can blur an image with:

    from PIL import Image, ImageFilter

    before = Image.open("bridge.bmp")
    after = before.filter(ImageFilter.BLUR)
    after.save("out.bmp")

* In Python, we include other libraries with import, and here we’ll import the Image and ImageFilter names from the PIL library.

We can implement a dictionary with:

    words = set()

    def check(word):
        if word.lower() in words:
            return True
        else:
            return False

    def load(dictionary):
        file = open(dictionary, "r")
        for line in file:
            words.add(line.rstrip("\n"))
        file.close()
        return True

    def size():
        return len(words)

    def unload():
        return True
        
* Swapping two variables can also be done by assigning both values at the same time:

        x = 1
        y = 2

        print(f"x is {x}, y is {y}")
        x, y = y, x
        print(f"x is {x}, y is {y}")

##### Files

* Let’s open a CSV file:

        import csv
        from cs50 import get_string

        file = open("phonebook.csv", "a")

        name = get_string("Name: ")
        number = get_string("Number: ")

        writer = csv.writer(file)
        writer.writerow((name, number))

        file.close()

### Regular Expressions

* A feature of Python that C does not have is regular expressions, or patterns against which we can match strings. For example, its syntax includes:
    * ., for any character
    * .*, for 0 or more characters
    * .+, for 1 or more characters
    * ?, for something optional
    * ^, for start of input
    * $, for end of input

            import re
            from cs50 import get_string

            s = get_string("Do you agree?\n")

            if re.search("^y(es)?$", s, re.IGNORECASE):
                print("Agreed.")
            elif re.search("^no?$", s, re.IGNORECASE):
                print("Not agreed.")

### Functions

#### DictReader

        >>> import csv
        >>> with open('names.csv', newline='') as csvfile:
        ...     reader = csv.DictReader(csvfile)
        ...     for row in reader:
        ...         print(row['first_name'], row['last_name'])
        ...
        Eric Idle
        John Cleese

        >>> print(row)
        {'first_name': 'John', 'last_name': 'Cleese'}


## Week 7 SQL

[SQL keywords reference](<https://www.w3schools.com/sql/sql_ref_keywords.asp>)

![sql](./images/ql-table.png)


#### Insert

Add information to a table

    INSERT INTO <table> (<columns>) VALUES (<values>)
    
    INSERT INTO users (username, password, fullname) VALUES ("newman", "USMAIL", "Newman")
    
    INSERT INTO moms (username, mother) VALUES ("kramer", "Babs Kramer")

#### Select

Extract Information from table

    SELECT <columns> FROM <table> WHERE <condition> ORDER BY <column>

    # WHERE and ORDER BY are optional

    SELECT idnum, fullname FROM users

    SELECT password FROM users WHERE idnum < 12

    SELECT * FROM moms WHERE username = "jerry"
    # Start is a shorthand for every columns

#### Select (JOIN)

Extract information from multiple tables

    SELECT <columns> FROM <table1> JOIN <table2> ON <predicate>

    SELECT users.fullname, moms.mother FROM users JOIN moms ON users.username = moms.username

#### UPDATE

Modify information in a table

    UPDATE <table> SET <column> = <value> WHERE <predicate>

    UPDATE users SET password = "yadayada" WHERE idnum = 10

#### Delete

Remove information from a table

    DELETE FROM <table> WHERE <predicate>

    DELETE FROM user WHERE username = "newman"

#### SQLite 3

* With .schema, we can see how the format for the table for our data is created:

        sqlite> .schema
        CREATE TABLE favorites(
        "Timestamp" TEXT,
        "title" TEXT,
        "genres" TEXT
        );

* We’ll run some commands to create a new database called favorites.db and import our CSV file into a table called “favorites”:

        ~/ $ sqlite3 favorites.db
        SQLite version 3.22.0 2018-01-22 18:45:57
        Enter ".help" for usage hints.
        sqlite> .mode csv
        sqlite> .import "CS50 2019 - Lecture 7 - Favorite TV Shows (Responses) - Form Responses 1.csv" favorites

* We see a favorites.db in our IDE after we run this, and now we can use SQL to interact with our data:

        sqlite> SELECT title FROM favorites;
        title
        Dynasty
        The Office
        Blindspot
        24
        Friends
        psych
        Veep
        Survivor
        ...

* We can even sort our results:

        sqlite> SELECT title FROM favorites ORDER BY title;

* And get a count of the number of times each title appears:

        sqlite> SELECT title, COUNT(title) FROM favorites GROUP BY title;

* We can even set the count of each title to a new variable, n, and order our results by that, in descending order. Then we can see the top 10 results with LIMIT 10:

        sqlite> SELECT title, COUNT(title) AS n FROM favorites GROUP BY title ORDER BY n DESC LIMIT 10;

* After inserting values, we can use functions to perform calculations, too:
    * AVG
    * COUNT
    * DISTINCT, for getting distinct values without duplicates
    * MAX
    * MIN
    * …

* There are also other operations we can combine as needed:
    * WHERE, matching on some strict condition
    * LIKE, matching on substrings for text
    * LIMIT
    * GROUP BY
    * ORDER BY
    * JOIN, combining data from multiple tables

#### Python & SQL

We’ll write import.py to read the file in:

    import csv

    # Open TSV file for reading
    with open("title.basics.tsv", "r") as titles:

        # Since the file is a TSV file, we can use the CSV reader and change
        # the separator to a tab.
        reader = csv.DictReader(titles, delimiter="\t")

        # Open new CSV file for writing
        with open("shows0.csv", "w") as shows:

            # Create writer
            writer = csv.writer(shows)

            # Write header of the columns we want
            writer.writerow(["tconst", "primaryTitle", "startYear", "genres"])

            # Iterate over TSV file
            for row in reader:

                # If non-adult TV show
                if row["titleType"] == "tvSeries" and row["isAdult"] == "0":

                    # If year not missing (We need to escape the backslash too)
                    if row["startYear"] != "\\N":

                        # If since 1970
                        if int(row["startYear"]) >= 1970:

                            # Write row
                            writer.writerow([row["tconst"], row["primaryTitle"], row["startYear"], row["genres"]])

* In Python, we can connect to a SQL database and read our file into it once, so we can make lots of queries without writing new programs and without having to read the entire file each time.
* Let’s do this more easily with the CS50 library:
* But each of the rows will only have one column for genres, and the values are multiple genres put together. So we can go back to our import program, and add another table:

        import cs50
        import csv

        # Create database
        open(f"shows4.db", "w").close()
        db = cs50.SQL("sqlite:///shows4.db")

        # Create tables
        db.execute("CREATE TABLE shows (id INT, title TEXT, year NUMERIC, PRIMARY KEY(id))")

        # The `genres` table will have a column called `show_id` that references
        # the `shows` table above
        db.execute("CREATE TABLE genres (show_id INT, genre TEXT, FOREIGN KEY(show_id) REFERENCES shows(id))")

        # Open TSV file
        # https://datasets.imdbws.com/title.basics.tsv.gz
        with open("title.basics.tsv", "r") as titles:

            # Create DictReader
            reader = csv.DictReader(titles, delimiter="\t")

            # Iterate over TSV file
            for row in reader:

                # If non-adult TV show
                if row["titleType"] == "tvSeries" and row["isAdult"] == "0":

                    # If year not missing
                    if row["startYear"] != "\\N":

                        # If since 1970
                        startYear = int(row["startYear"])
                        if startYear >= 1970:

                            # Trim prefix from tconst
                            id = int(row["tconst"][2:])

                            # Insert show
                            db.execute("INSERT INTO shows (id, title, year) VALUES(?, ?, ?)", id, row["primaryTitle"], startYear)

                            # Insert genres
                            if row["genres"] != "\\N":
                                for genre in row["genres"].split(","):
                                    db.execute("INSERT INTO genres (show_id, genre) VALUES(?, ?)", id, genre)

* Now we can run sqlite3 shows3.db and run commands like before, such as SELECT * FROM shows LIMIT 10;        

* In fact, we can combine both tables with SELECT * FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = "Comedy") AND year = 2019;. We’re filtering our shows table by IDs where the ID in the genres table has a value of “Comedy” for the genre column, and has the value of 2019 for the year column.
Our tables look like this:

![diagram-sql](images\shows_table_genres_table.png)

#### Snippets

* SELECT title, COUNT(title) AS n FROM favorites GROUP BY tittle ORDER BY n DESC LIMIT 10;

    - title, COUNT(title): ill give us the number of times that title apear: GOT | 2
    - AS n: ill give the parameter COUNT(title) the name n so we can sorted
    - GROUP BY title: ill group the db by title so similiar titles can be close
    - ORDER BY n DESC: ill sorted the db in a descent way by number of times the title appear
    - LIMIT 10 : ill only appear the 10 first elements of the db

* SELECT titel FROM favorites WHERE title LIKE "%office%";

    - WHERE title ... : is a start of  a condition
    - LIKE "%office%" : is something similiar to what we are putting
    - "%office%" : the % means that i dont care what is behond and in front that just it has office return to me

* UPDATE favorites SET title = "The Office" WHERE title LIKE "%office%";

    - SET title = "The Office" WHERE title LIKE "%office%": is to change the condition that satisfies all title that has office to "The Office"

* SELECT * FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = "Comedy") AND year = 2019;
    
    - IN (SELECT ....): ill select all show_id comedys rows in the genres table, so that
    - WHERE id IN : is a condition that ill be the result of what is next IN
    - AND year = 2019: another condition

* SELECT * FROM shows JOIN genres ON shows.id = genres.show_id WHERE title = "The Crown" AND year = 2020;

    - shows JOIN genres ON shows.id = genres.show_id: ill join temporary two tables and linked them by id

* SELECT name FROM people WHERE id IN (SELECT person_id FROM stars WHERE movie_id = (SELECT id FROM movies WHERE title LIKE "%Toy Story%"));

    - This ill get the id from a table movie, compare the movie_id to another person_id and then that person_id ill get the name of the people that belong to that movie

* SELECT title, rating FROM movies JOIN ratings ON movies.id = ratings.movie_id WHERE year = 2010 ORDER BY rating DESC, title;

    - ORDER BY rating DESC, title: ill first order by rating descending way and if the same rating order by alfabethical